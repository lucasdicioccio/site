<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./hsstyle.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul><li><a href="#haskell-in-fewer-than-10e6-ms.">Haskell in fewer than 10e6 ms.</a></li><li><a href="#my-viewpoint-on-engineering">My viewpoint on engineering</a></li><li><a href="#types-provide-a-logical-framework-to-define-and-combine-data-structures">Types provide a logical framework to define and combine data structures</a></li><li><a href="#purity-revolves-around-a-simple-principle-referential-transparency">Purity revolves around a simple principle: referential transparency</a></li><li><a href="#functional-problem-solving-is-exciting-and-offers-hindsight">Functional problem solving is exciting and offers hindsight</a></li><li><a href="#practical-life-of-a-haskeller">Practical life of a Haskeller</a></li><li><a href="#good-to-know">Good to know</a></li><li><a href="#algebraic-jargon-is-precise">Algebraic jargon is precise</a></li></ul>
</div>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ --><title>Haskell code</title><link type='text/css' rel='stylesheet' href='hscolour.css' /></head><body><hr /><h1 id="haskell-in-fewer-than-10e6-ms.">Haskell in fewer than 10e6 ms.</h1><ul><li><em>Goal today</em>: entice you into learning some Haskell/OCaml/Typed-FP-au-choix</li><li>“hash-tag”: <strong><span class="citation">@while42London</span></strong></li><li><em>Caution</em> <em>Caution</em> <em>Caution</em> slides will show some code. Some syntax I use does not exist but make things “pretty”.</li></ul><hr /><h1 id="my-viewpoint-on-engineering">My viewpoint on engineering</h1><ul><li>The Maslow pyramid of needs</li></ul><p><code>food &gt; safety &gt; love &gt; esteem &gt; self-actualization</code></p><ul><li>The lucasdicioccio pyramid of solutions</li></ul><p><code>timeliness &gt; correctness &gt; maintainability &gt; prettiness &gt; light-shedding</code></p><ul><li>I can write “quick-and-dirty” code just fine now, but I know that making leaps upward is pretty cheap with Haskell.</li><li>Correctness for most stupid yet time-consuming errors is basically free.</li><li>The light cost of types allows to concisely and precisely model important features.</li><li>The syntax is a bit foreign at first but “side effects as values” and the “do-notation” allow for cute embedded-DSLs.</li><li>In a number of instances, you realize you gained a lot of hindsight about the problem you were solving and are able to connect it to other solutions.</li><li>Please, do challenge people who tell Haskell is not “practical”. Ask them to give you solid arguments and match these arguments against your own “pyramid of needs”. Maybe they have a good but out-of-date picture of things, especially from people isolated from typed-FP for years.</li></ul><hr /><h1 id="types-provide-a-logical-framework-to-define-and-combine-data-structures">Types provide a logical framework to define and combine data structures</h1><ul><li>data types are <strong>cheap</strong> and <strong>expressive</strong></li><li>if you are used to BNF grammar, data types definitions will look familiar</li></ul><pre><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Bool</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>False</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Int16</span>          <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>2</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>3</span> <span class='hs-keyglyph'>|</span> <span class='hs-varop'>...</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>65535</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Int</span>            <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>2</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>3</span> <span class='hs-keyglyph'>|</span> <span class='hs-varop'>...</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Triple</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Function</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Func</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Function</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Func</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>a</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Tree</span> <span class='hs-varid'>a</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Leaf</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Bin</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tree</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tree</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
</pre><ul><li>data types help you make invalid program states un-expressible</li></ul><pre><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Four</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>carWheelsA</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Wheels</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- list of wheels for a car</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>carWheelsB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Four</span> <span class='hs-conid'>Wheels</span>  <span class='hs-comment'>-- exactly Four wheels for a car</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- With the B definition, no need to litter code with length</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- checks or asserts, you cannot build a car with two many or two</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- few wheels. Basically turning the compiler into an automated</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- and meticulous test suites.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- You could do the same in Java but the syntax overhead is</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- significant.</span>
</pre><pre><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>
<span class='hs-varop'>&gt;</span>                      <span class='hs-comment'>--          ^ this 'or' is the bit of information</span>
<span class='hs-varop'>&gt;</span>                      <span class='hs-comment'>-- telling whether a value exists or not</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>baldwin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>User</span>  <span class='hs-comment'>-- Nothing | Just User</span>
<span class='hs-varop'>&gt;</span>                              <span class='hs-comment'>--                    ^ user baldwin</span>
<span class='hs-varop'>&gt;</span>                              <span class='hs-comment'>--               ^ proof carrying user baldwin</span>
<span class='hs-varop'>&gt;</span>                              <span class='hs-comment'>-- ^ baldwin doesn't exist</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- say we have a function returning the name for a User</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>userName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>User</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- We need to prove that (baldwin :: Maybe User) is not Nothing before</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- username. If we want to get a Name value out of baldwin we</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- provide a value for the Nothing case.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>newPersonName</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>baldwin</span> <span class='hs-keyword'>of</span>
<span class='hs-varop'>&gt;</span>                           <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>user</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>userName</span> <span class='hs-varid'>user</span>
<span class='hs-varop'>&gt;</span>                           <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>=</span> <span class='hs-str'>"bruce"</span> <span class='hs-comment'>-- let's call him Bruce, that</span>
<span class='hs-varop'>&gt;</span>                                                 <span class='hs-comment'>-- will avoid confusion.</span>
</pre><ul><li><em>key takeaway</em>: algebraic data types as a support for reasoning</li></ul><hr /><h1 id="purity-revolves-around-a-simple-principle-referential-transparency">Purity revolves around a simple principle: referential transparency</h1><ul><li>definition: you can swap the result of a computation for the computation</li><li>in layman terms: cut-n-paste is correct</li></ul><pre><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- partition a list in two sublists using a boolean function</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- naive algorithm, unreadable version</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>partition</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>partition</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>                        <span class='hs-comment'>-- ^ comprehension lists </span>
<span class='hs-varop'>&gt;</span>                        <span class='hs-comment'>--       `for x in xs if f(x) is True` =&gt; to the left sublist</span>
<span class='hs-varop'>&gt;</span>                        <span class='hs-comment'>--       `for x in xs if f(x) is False` =&gt; to the right sublist</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- naive algorithm, refactored by copy-pasting and names to the left</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- and right sublists</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>partition</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>leftList</span><span class='hs-layout'>,</span> <span class='hs-varid'>rightList</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span> <span class='hs-varid'>leftList</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>                                                      <span class='hs-varid'>rightList</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>                                                   <span class='hs-comment'>-- ^ call these "names" rather than "variables"</span>
</pre><ul><li>Referential transparency blurs the concept of “variable”: we only have names for “values we carry around” (e.g., <code>left</code>, <code>right</code>)</li><li>Referential transparency blurs the concept of “result”: we only have names for “values we want to compute” (e.g., <code>partition f [1,2,3]</code>)</li><li>Referential transparency necessitates a trick to represent side-effects because side-effect cannot be swapped for their result (e.g., result of an HTTP get to the weather forecast website will depends on the day you apply the side-effect).</li><li>Haskell uses one level of indirection: side-effects are normal values. And one combines side-effects together to piece a single <code>main</code> side-effect.</li><li>In short, <code>main</code> actually is a <strong>single</strong> IO () action composed from many small actions. The compiler effectively is a function from a value of type <code>IO ()</code> returning an executable binary program that your OS understands.</li></ul><pre><span class='hs-varop'>&gt;</span>        <span class='hs-varid'>actions</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- a list of side effects</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-varid'>actions</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>putStrLn</span> <span class='hs-str'>"hello"</span><span class='hs-layout'>,</span> <span class='hs-varid'>putStrLn</span> <span class='hs-str'>"world"</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-comment'>-- the only thing capable of observing the content of IO () is the runtime</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-varid'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span>        <span class='hs-varid'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sequence</span> <span class='hs-varid'>actions</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>putStrLn</span> <span class='hs-str'>"done"</span>
<span class='hs-varop'>&gt;</span>            <span class='hs-comment'>-- ^ turns a list of side-effects into a single side-effect by</span>
<span class='hs-varop'>&gt;</span>            <span class='hs-comment'>--   sequencing actions starting from the left of the list</span>
<span class='hs-varop'>&gt;</span>                             <span class='hs-comment'>-- ^ the (&gt;&gt;) operator sequences exactly two side effect</span>
</pre><ul><li><em>key takeaway</em>: purity makes it easier to cut-n-paste code (including when self-talking).</li><li><em>key takeaway</em>: purity elevates side-effects to the rank of normal values, no need to jail side-effects in a function/lambda/proc/block to pass them around.</li></ul><hr /><h1 id="functional-problem-solving-is-exciting-and-offers-hindsight">Functional problem solving is exciting and offers hindsight</h1><ul><li><strong>reasoning on types</strong>: is there a huge difference between a read-only key/value dictionary and a function?</li></ul><pre><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>someFunction</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arg1</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arg2</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Value</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>lookup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-conid'>Key</span> <span class='hs-conid'>Value</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Key</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Value</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- A function "maps" a return value to some argument.</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- A dictionary "maps" a return value to some key, but the key might be missing.</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- This is why a dictionary is a nice way to "cache results".</span>
</pre><ul><li><strong>partial application</strong>: capture only the parameters you know or need, you will complete this later.</li></ul><pre><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- I need three things to make some crepes.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>makeCrepes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Milk</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Flour</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Egg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Crepes</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- If I have Milk in the fridge I could partially apply the milk.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>makeCrepes</span> <span class='hs-varid'>milkFromFridge</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Flour</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Egg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Crepes</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- Then maybe my neighbor has some Flour</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>makeCrepes</span> <span class='hs-varid'>milkFromFridge</span> <span class='hs-varid'>flourFromNeighbor</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Egg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Crepes</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- We just need to buy eggs.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>makeCrepes</span> <span class='hs-varid'>milkFromFridge</span> <span class='hs-varid'>flourFromNeighbor</span> <span class='hs-varid'>eggsFromFarmer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Crepes</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- In another scenario, we may have had Flour and Eggs at home, we</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- can still use the same recipe (real code would need you to add</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- some boilerplate to move arguments around).</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>makeCrepes</span> <span class='hs-varid'>flourFromHome</span> <span class='hs-varid'>eggsFromHome</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Milk</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Crepes</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- Note: in real life, you shouldn't put the milk first because</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- mixing ingredients has side-effects. The type system let you models</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- requirements well because you cannot observe any</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- crepes-making side-effect until you have all ingredients to</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- start. That is, you cannot start cooking and figure out later that you</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- lack an ingredient.  Also, the makeCrepes function does not</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- expose intermediary steps, which prevents your secret</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- trick to make the tastiest crepes.</span>
</pre><ul><li><strong>parametricity</strong> prevents observation (a.k.a universal quantification)</li></ul><pre><span class='hs-varop'>&gt;</span>           <span class='hs-varid'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- promises to work for "any" `a` you can</span>
<span class='hs-varop'>&gt;</span>                                <span class='hs-comment'>-- imagine (i.e., for all `a`). Thus, length</span>
<span class='hs-varop'>&gt;</span>                                <span class='hs-comment'>-- cannot "observe" the values in the list,</span>
<span class='hs-varop'>&gt;</span>                                <span class='hs-comment'>-- the result can only depends on the shape of</span>
<span class='hs-varop'>&gt;</span>                                <span class='hs-comment'>-- the list, not its content.</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>length</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nothing</span><span class='hs-keyglyph'>]</span>                                        <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>length</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>User</span> <span class='hs-str'>"Grace Hopper"</span><span class='hs-keyglyph'>]</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>length</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>error</span> <span class='hs-str'>"if-you-evaluate-me-the-program-crashes"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- Another way to put it is that you could drop the information `a`</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- in the list and obtain the same result.</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- That is, if you promise to never observe the content of a list, the only</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- thing you can do with the list is count how many elements there</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- are, but nothing more fancy. In practice, if you do such a</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- promise you need not pay the cost of carrying-around the `a` items</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- of the list. Suddenly, your list looks like just a natural</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- number corresponding to the length of the list. Reasoning on</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- types shows this interesting fact pretty nicely:</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span>      <span class='hs-varid'>a</span><span class='hs-layout'>,</span>  <span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>data</span> <span class='hs-conid'>Natural</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Zero</span>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>PlusOne</span><span class='hs-layout'>,</span> <span class='hs-conid'>Natural</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>[</span><span class='hs-str'>"hello"</span><span class='hs-layout'>,</span> <span class='hs-str'>"world"</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-str'>"hello"</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"world"</span><span class='hs-layout'>,</span> <span class='hs-conid'>Empty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>[</span>     <span class='hs-num'>42</span><span class='hs-layout'>,</span>      <span class='hs-num'>51</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span>     <span class='hs-num'>42</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span>     <span class='hs-num'>51</span><span class='hs-layout'>,</span> <span class='hs-conid'>Empty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- If we focus only on the shape of the list:</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>[</span><span class='hs-sel'>______</span> <span class='hs-layout'>,</span> <span class='hs-sel'>_______</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-sel'>_______</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-sel'>_______</span><span class='hs-layout'>,</span> <span class='hs-conid'>Empty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-conid'>TwoThings</span>           <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>PlusOne</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>PlusOne</span><span class='hs-layout'>,</span> <span class='hs-conid'>Zero</span> <span class='hs-layout'>)</span><span class='hs-layout'>)</span>
</pre><ul><li><strong>laziness</strong>: expresses the mathematical statement defining a value, computation will occur as needed</li></ul><pre><span class='hs-varop'>&gt;</span>           <span class='hs-varid'>fibs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-varid'>fibs</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-conop'>:</span> <span class='hs-num'>1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>fibs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>fibs</span><span class='hs-layout'>)</span> 
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- read this as: fibs is a list of Int starting with 0, followed by 1</span>
<span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- followed by the list of sums of the fibs list and the fibs list shifted by one item</span>
<span class='hs-varop'>&gt;</span>    
<span class='hs-varop'>&gt;</span>                    <span class='hs-varid'>fibs</span>      <span class='hs-keyglyph'>=</span>  <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-num'>5</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>                                     <span class='hs-comment'>-- ^ depends on `zipWith...` starting from here</span>
<span class='hs-varop'>&gt;</span>                    <span class='hs-varid'>tail</span> <span class='hs-varid'>fibs</span> <span class='hs-keyglyph'>=</span>  <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-num'>5</span><span class='hs-layout'>,</span> <span class='hs-num'>8</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>                               <span class='hs-comment'>-- ^ the 1st value depends only on fibs 2nd</span>
<span class='hs-varop'>&gt;</span>                               <span class='hs-comment'>--   item, not the full list</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>fibs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>fibs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-num'>3</span><span class='hs-layout'>,</span> <span class='hs-num'>5</span><span class='hs-layout'>,</span> <span class='hs-num'>8</span><span class='hs-layout'>,</span> <span class='hs-num'>13</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>                               <span class='hs-comment'>-- ^ the 1st value depends only on fibs and</span>
<span class='hs-varop'>&gt;</span>                               <span class='hs-comment'>--   (tail fibs) 1st items, not the full lists</span>
</pre><ul><li><em>key takeaway</em>: functional thinking let you state a large problem and deliver its solution focusing on small bits</li></ul><hr /><h1 id="practical-life-of-a-haskeller">Practical life of a Haskeller</h1><ul><li>great feeling of having done the things right</li><li>steep but fulfilling learning curve</li><li>fearless parallelism and concurrency thanks to purity-by-default (enforced by the compiler) rather than purity-by-scrutiny (enforced by your colleagues)</li><li>good memory footprint, decent speed, and pretty extensive profiling support/GC-knobs</li><li>lots of amazing libraries (for parsing, for testing, to interface with C or R, to write web micro-services, connect to databases etc.) on Hackage</li><li>long compile-time and some amount of dependency hell, being fixed</li><li>some impedance mismatch between strong types and things where the “shape” of a same data varies widely with the input (e.g., <code>SELECT colnames</code> in SQL). One can give-away the type-safety and treat all columns as equal but feels less idiomatic.</li><li><em>key takeaway</em>: learn it now or re-invent a half-baked version using “best-practices” later</li></ul><hr /><h1 id="good-to-know">Good to know</h1><ul><li>Two Meetup-groups in London</li><li>Growing number of companies ready to pay for functional programmers, including Haskell</li><li>Curated list of videos on GitHub &gt;&gt;= search-for: haskell-must-watch</li><li>Real-World-Haskell is very practical</li><li>Write Yourself a Scheme in 48h, the best way I found to cement what I learned</li><li>John Carmack QuakeCon’s talk, he rocks</li></ul><hr /><h1 id="algebraic-jargon-is-precise">Algebraic jargon is precise</h1><ul><li>The goal of jargon is to capture a particular behavior in terms of constraints.</li><li><strong>monoids</strong>: very generic way of combining two values</li></ul><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Always remember that one monoid is three things:</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--   i. a set of values</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  ii. an associative, binary operator on the set of values</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- iii. a specific element in the set which is "neutral" for the operator</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Strings give a monoid with `++` (concatenation) and `""` (empty string).</span>
<span class='hs-varop'>&gt;</span>  <span class='hs-layout'>(</span><span class='hs-str'>"he"</span> <span class='hs-varop'>++</span> <span class='hs-str'>""</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>""</span> <span class='hs-varop'>++</span> <span class='hs-str'>"llo"</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-str'>""</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-str'>"world"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"he"</span> <span class='hs-varop'>++</span> <span class='hs-str'>"llo"</span> <span class='hs-varop'>++</span> <span class='hs-str'>"world"</span>
</pre><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Natural numbers give a monoid with `+` (addition) and `0` (zero).</span>
<span class='hs-varop'>&gt;</span>  <span class='hs-layout'>(</span><span class='hs-num'>2</span>     <span class='hs-varop'>+</span>  <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span>  <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>0</span>  <span class='hs-varop'>+</span>      <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span>   <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span>        <span class='hs-num'>5</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>     <span class='hs-varop'>+</span> <span class='hs-num'>3</span>      <span class='hs-varop'>+</span>       <span class='hs-num'>5</span>
</pre><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Natural numbers also give a monoid with `*` (multiplication) and `1` (one).</span>
<span class='hs-varop'>&gt;</span>  <span class='hs-layout'>(</span><span class='hs-num'>2</span>     <span class='hs-varop'>*</span>  <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span>  <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>1</span>  <span class='hs-varop'>*</span>      <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span>   <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>*</span>        <span class='hs-num'>5</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>     <span class='hs-varop'>*</span> <span class='hs-num'>3</span>      <span class='hs-varop'>*</span>       <span class='hs-num'>5</span>
</pre><ul><li><strong>functor</strong>: what does it mean to have a context?</li></ul><pre><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- only function for a Functor is the equivalent to map on lists:</span>
<span class='hs-varop'>&gt;</span>    <span class='hs-varid'>map</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>]</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span> <span class='hs-varid'>b</span>   <span class='hs-comment'>-- here `t` is the functor and could be `List`</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- Thus, since the only function to operate on a functor is `fmap`.</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- partially-applying fmap to `t a` gives. `(a -&gt; b) -&gt; t b`.</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- That is, a functor object is a _consumer_ of functions which modify</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- _produced_ values (nit: the functor may never _produce_ any value but</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- the type changes anyway).</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- For instance IO is a functor. Say we can read some Text file given a file path.</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>readFile</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Text</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- And we know how to counts lines of text.</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>countLines</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Text</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- We can ask readFile to ingest countLines with fmap.</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>countFileLines</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>countFileLines</span> <span class='hs-varid'>path</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>countLines</span> <span class='hs-layout'>(</span><span class='hs-varid'>readFile</span> <span class='hs-varid'>path</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> 
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- In this example we didn't have to run side effects. We just adapted the value</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- produced by the readFile result. Functor requires some theoretical guarantees</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- so that you can count on `fmap` to do-the-right-thing(tm).</span>
</pre><ul><li><strong>applicative functors</strong>: what does it mean to merge functors “side-by-side” when applying some function?</li></ul><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  +--------+     +---+      +---+</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  | a -&gt; b | &lt;*&gt; | a |   =  | b |</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  +--------+     +---+      +---+</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--     Foo          Bar        FooBar</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- One theoretical guarantee for Applicative is that both contexts are</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- independent from each other (i.e., the value Bar cannot depend on the</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- value of `a-&gt;b`, `a`, or `b`).</span>
</pre><ul><li><strong>monads</strong>: what does it mean to merge the nesting of a same functors?</li></ul><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  +-------+   </span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  | +---+ |             +---+</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  | | c | |  #join  =   | c |</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  | +---+ |             +---+</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  |  Foo  |              FooBar</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--  +-------+   </span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--     Bar</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>--</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- Monads drop the guarantee that contexts are independent from each other.</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- (i.e., the value Bar may depend on the value `c`, hence changing the</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- course of actions as we merge levels of nesting (e.g., being Baz)).</span>
</pre><ul><li><em>key takeaway</em>: a pretty small set of alien abstractions allow you to express a broad range of problems.</li></ul></body></html>
</body>
</html>
